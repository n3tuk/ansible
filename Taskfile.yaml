---
version: 3
output: prefixed

# This Taskfile is configured to minimise dependencies and run most tasks in a
# semi-sequential way, which reduces issues with parallel task contexts being
# cancelled following failures. This helps the interval stay low. However, if
# there are issues with tasks running continuously, or being re-added to the
# queue multiple times due to regular changes, increase the value for the watch
# interval to take into account the typical longest running task in the set.
interval: 2s

# Enforce the pipefail option in the Bash library to ensure that where commands
# are run through pipes, the failure of any one step in the pipeline fails the
# whole pipe. For example, terraform |& tee will not normally fail if Terraform
# fails as tee almost always will exit cleanly, unless pipefail is set.
set:
  - pipefail

env:
  limit: '{{ .limit | default "all" }}'
  tags: '{{ .tags | default "" }}'

vars:
  # ANSI Colours
  cg: \e[0;31m
  cw: \e[1;37m
  cc: \e[0m

  # Work out the full path to the root of this repository to allow us to create
  # absolute paths to configuration files, caches, etc., rather than attempt to
  # generate relative links programmatically
  root:
    sh: git rev-parse --show-toplevel

# To help improve management of all the tasks supported within this repository,
# many have been broken out into dedicated files grouped by the sections they
# operate against, so, here, include them into the main Taskfile workflow
includes:
  utils:
    taskfile: .taskfiles/utils.yaml
    flatten: true
  prettier:
    taskfile: .taskfiles/prettier.yaml
    flatten: true
  yamllint:
    taskfile: .taskfiles/yamllint.yaml
    flatten: true
  markdownlint:
    taskfile: .taskfiles/markdownlint.yaml
    flatten: true
  jsonschema:
    taskfile: .taskfiles/jsonschema.yaml
    flatten: true
  # trivy:
  #   taskfile: .taskfiles/trivy.yaml
  #   flatten: true

  ping:
    taskfile: .taskfiles/ping.yaml
    flatten: true
  ansible:
    taskfile: .taskfiles/ansible.yaml
    flatten: true

tasks:
  default:
    desc: Run the development and integration tasks once
    summary: |-
      Clean the environment and then run the development and integration tasks
      for all resources by testing and checking the code and files, but only
      once rather than continuously.

      Use the following command for additional information on the steps
      involved:

      $ task --summary develop
    silent: true
    cmds:
      - task: develop

  develop:
    desc: Continuously run the development and integration tasks
    summary: |-
      The develop task is designed to perform continuous integration on code
      changes within this repository, first by cleaning the repository and then
      running the following tasks when any relevant files are changed:

      - Lint all supported files, ensuring their layout and syntax are correct
        and consistent before staging and commiting changes;
      - Validate the Ansbile configuration to ensure it is valid and can be
        run to deploy and configure resources; and
      - Run static code analysis against the Ansible configuration and any
        associated resoruces to look for potential security issues or
        misconfigurations.
    silent: true
    watch: true
    deps:
      - task: pre-commit
      - task: pre-checks
      - task: clean
    cmds:
      - task: lint

  lint:
    desc: Lint selected files within this repository
    summary: |-
      Run linting checks across the GitHub Workflows, repository configuration
      files, Terraform (and other) code, and all documentation to find any
      potential issues within the repository by running the following steps:

      - Parse all JSON, YAML, and Markdown files through Prettier in order to
        ensure they are syntactically correct, and that they are consistent in
        their layout and usage;
      - Parse selected configurations (Task files, GitHub Dependabot
        configuration, and GitHub Workflows) through JSON Schema to evaluate
        these free-from configuration types are correctly structured for their
        intended usage (i.e. keys are in the right place, the values are what is
        expected or supported, and required settings are present);
      - Review the format of Markdown files to ensure they are clean and
        minimise the ability for the page to be incorrectly rendered, such as
        de-duplicating headers, consistent text width, formatted list items,
        and code layouts.
      - Run tflint on the Terraform configuration, making sure that any
        Terraform code is syntactically correct, properly formatted, and mostly
        valid for runtime (e.g. using correct instance types, names are not too
        long, and resource names are correctly formatted).
    silent: true
    cmds:
      - task: prettier
      - task: markdownlint
      - task: jsonschema

  rename:
    desc: Find and rename all .yml files to .yaml
    sources:
      - "**.yml"
    silent: true
    cmds:
      - cmd: |-
          find -type f -iname '*.yml' | while read file
          do
            echo "${file#\./} -> $(basename $file .yml).yaml"
            git mv -f $file ${file%.yml}.yaml 2>/dev/null \
             || mv -f $file ${file%.yml}.yaml
          done

  play:bootstrap:
    desc: Run the {{ name }} Ansible Playbook
    silent: true
    deps:
      - task: jsonschema:ansible
    env:
      ANSIBLE_FORCE_COLOR: true
    cmds:
      - cmd: |-
          ansible-playbook \
            --syntax-check \
            plays/bootstrap.yaml
          echo -e '{{ .cg }}Checked{{ .cc }}'
      - cmd: |-
          ansible-playbook \
            --limit {{ .limit }} \
            --ask-pass \
            plays/bootstrap.yaml

  play:*:
    label: '{{ trimSuffix ":*" .TASK }}:{{ "{" }}play{{ "}" }}'
    desc: Run the named Ansible Playbook
    summary: |-
      Run the specified Ansible Playbook from within the plays/ directory. For
      example, to run the `baseline.yaml` playbook, use:

      $ task play:baseline

      This will first perform a syntax check on the playbook to ensure it is
      valid, and then run it against the hosts defined within the playbook in
      check mode. Ansible can be limited to execution on those hosts defined by
      the `--limit` parameter (by passing the argument limit={{ .limit }}),
      which defaults to `all`.

      $ task play:baseline limit=arch

      If the file plays/encrypted_vars/become.yaml exists, it will be passed to
      Ansible as an extra-vars file to provide become passwords for hosts that
      require them.
    vars:
      name: "{{ index .MATCH 0 }}"
      options:
        sh: |-
          if [[ -n "{{ .tags }}" ]]; then
            echo -n " --tags {{ .tags }}"
          fi
      become:
        sh: |-
          if [[ -f plays/encrypted_vars/become.yaml ]]; then
            echo -n "--extra-vars @plays/encrypted_vars/become.yaml"
          fi
    env:
      ANSIBLE_FORCE_COLOR: true
    deps:
      - task: jsonschema:ansible
    prefix: '{{ trimSuffix ":*" .TASK }}:{{ index .MATCH 0 }}'
    silent: true
    cmds:
      - cmd: |-
          ansible-playbook \
            --syntax-check \
            plays/{{ .name }}.yaml
          echo -e '{{ .cg }}Checked{{ .cc }}'
      - cmd: |-
          ansible-playbook \
            {{ .become }}{{ .options }} \
            --limit {{ .limit }} \
            plays/{{ .name }}.yaml

  test:*:
    label: '{{ trimSuffix ":*" .TASK }}:{{ "{" }}play{{ "}" }}'
    desc: Check the named Ansible Playbook
    summary: |-
      Run the specified Ansible Playbook from within the plays/ directory in
      check mode. For example, to run the `baseline.yaml` playbook, use:

      $ task test:baseline

      This will first perform a syntax check on the playbook to ensure it is
      valid, and then run it against the hosts defined within the playbook in
      check mode. Ansible can be limited to execution on those hosts defined by
      the `--limit` parameter (by passing the argument limit={{ .limit }}),
      which defaults to `all`.

      All tasks will be dry-run in diff mode to show what changes would be made
      without making any changes.

      $ task test:baseline limit=arch

      If the file plays/encrypted_vars/become.yaml exists, it will be passed to
      Ansible as an extra-vars file to provide become passwords for hosts that
      require them.
    vars:
      name: "{{ index .MATCH 0 }}"
      options:
        sh: |-
          if [[ -n "{{ .tags }}" ]]; then
            echo -n " --tags {{ .tags }}"
          fi
      become:
        sh: |-
          if [[ -f plays/encrypted_vars/become.yaml ]]; then
            echo -n "--extra-vars @plays/encrypted_vars/become.yaml"
          fi
    env:
      ANSIBLE_FORCE_COLOR: true
    deps:
      - task: jsonschema:ansible
    prefix: '{{ trimSuffix ":*" .TASK }}:{{ index .MATCH 0 }}'
    silent: true
    cmds:
      - cmd: |-
          ansible-playbook \
            --syntax-check \
            plays/{{ .name }}.yaml
          echo -e '{{ .cg }}Checked{{ .cc }}'
      - cmd: |-
          ansible-playbook \
            {{ .become }}{{ .options }} \
            --check --diff \
            --limit {{ .limit }} \
            plays/{{ .name }}.yaml

  clean:
    desc: Clean temporary files from the repository and configurations
    silent: true
    summary: |-
      Clean any temporary directories and files created by both this Taskfile,
      and the tools and applications called from it, and from within the
      configurations.
    run: once
    cmds:
      - cmd: rm -f .prettiercache
      - cmd: rm -rf .task
      - cmd: rm -rf .cache
      - cmd: echo -e '{{ .cg }}Completed{{ .cc }}'
